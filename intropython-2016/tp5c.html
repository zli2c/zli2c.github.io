<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Zhentao Li" />
  <title>Initiation à la programmation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>



<body>
<br />
<table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tr> 
    <td colspan="3" class="pos1" height="55" valign="middle"> 
			<div class="topbox">
			<table width="100%"><tr><td>
				<h2>Zhentao Li's Homepage</h2>
			<td align="right"><h4><b>email:</b>zl zli2 com</h4></td></tr></table>
			</div>
    </td>
  </tr>
  <tr> 
  <td>
   <table width="100%" border="0" cellpadding="0" cellspacing="0" class="topnav">
    <tr>
  	      <td align="left" class="head">
		  	&nbsp;// <a href="../index.html">home</a> 
           		   
		  </td>
	</tr>
   </table>
   </td>
  </tr>
  <tr> 
    <td> 
      <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr> 
          <td valign="top" width="150"> <br />
	    <div>
              <div class="headbox">Liens utiles</div>
              <a class="leftmenu" href="http://www.pythontutor.com/visualize.html#mode=edit">Python tutor</a>
	      <a class="leftmenu" href="https://fr.wikibooks.org/wiki/Apprendre_%C3%A0_programmer_avec_Python">Wikibook</a>
	      <a class="leftmenu" href="https://python.org">Site officiel Python</a>
              <div class="headbox">Cours</div>
              <a class="leftmenu" href=".">Page d'accueil</a> 
              <a class="leftmenu" href="tp1.html">Cours 1</a> 
              <a class="leftmenu" href="tp1c.html">Corrigé 1</a> 
              <a class="leftmenu" href="tp2.html">Cours 2</a> 
              <a class="leftmenu" href="tp2c.html">Corrigé 2</a> 
              <a class="leftmenu" href="tp3.html">Cours 3</a> 
              <a class="leftmenu" href="tp3c.html">Corrigé 3</a> 
              <a class="leftmenu" href="tp4.html">Cours 4</a> 
              <a class="leftmenu" href="tp4c.html">Corrigé 4</a> 
              <a class="leftmenu" href="tp5.html">Cours 5</a> 
              <a class="leftmenu" href="tp5c.html">Corrigé 5</a> 
              <a class="leftmenu" href="tp6.html">Cours 6</a> 
              <a class="leftmenu" href="tp6c.html">Corrigé 6</a> 
              <a class="leftmenu" href="tp7.html">Cours 7</a> 
          </td>


          <td valign="top"> <br />
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="10"></td>
                <td valign="top" class="mainbox">

<h2 id="exercice-1---pyramide-des-âges">Exercice 1 - Pyramide des âges</h2>
<p>Le fichier <a href="ages-2013.txt" class="uri">ages-2013.txt</a> contient le recensement de la population des régions de la France métropolitaine en 2013 (selon l'<a href="http://www.insee.fr/">INSEE</a>).</p>
<pre class="wrapper"><code>Homme 0 à 19 ans,Homme 20 à 39 ans,Homme 40 à 59 ans,Homme 60 à 74 ans,Homme 75 ans et plus,Femme 0 à 19 ans,Femme 20 à 39 ans,Femme 40 à 59 ans,Femme 60 à 74 ans,Femme 75 ans et plus
Alsace,228114,232452,262694,130053,56677,217353,236656,264906,136065,96050
Aquitaine,379188,375522,442336,258219,134564,362797,380724,463419,287831,218792
Auvergne,149863,151217,186737,112709,56890,144904,147238,187984,121273,96815</code></pre>
<p>Les résultats sont regroupés par région, sexe et grande classe d'âge.</p>
<ul>
<li>La première ligne contient les catégories (sexe et classe d'âge), séparés de virgules.</li>
<li>Chaque ligne suivante contient le nom de la région suivi du nombre de personne recensé pour chaque catégorie dans cette région. Toutes ces informations sont séparés d'une virgule.</li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Écrire un script Python chargeant le fichier dans deux <em>array</em> à deux dimensions (un par sexe) associant aux catégorie d'âge et aux régions le nombre d'habitants correspondants.</p></li>
<li><p>Modifier le script pour qu'il calcule la population totale d'une région par catégorie d'âge. Faire ce calcul pour toutes les régions.</p></li>
<li><p>Modifier le script pour qu'il trouve la région le plus jeune, le plus agé, le plus masculin et le plus féminin (en moyenne sur la population de la région).</p></li>
<li><p>Modifier le script pour qu'il calcule le coefficient de corrélation des âges correspondant à deux régions quelconques puis qu'il affiche les régions où les âges de la population sont les plus corrélés.</p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> scipy <span class="im">as</span> sp
<span class="kw">def</span> lecture():
    rangees <span class="op">=</span> <span class="bu">open</span>(<span class="st">&quot;ages-2013.txt&quot;</span>).readlines()
    <span class="co"># La premiere ligne contient les categories</span>
    categories <span class="op">=</span> []
    categories <span class="op">=</span> sp.array(rangees[<span class="dv">0</span>].split(<span class="st">&quot;,&quot;</span>)[<span class="dv">1</span>:])

    liste_homme <span class="op">=</span> []
    liste_femme <span class="op">=</span> []
    regions <span class="op">=</span> []
    <span class="co"># La derniere ligne est vide donc on ne la lit pas.</span>
    <span class="cf">for</span> rangee <span class="op">in</span> rangees[<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>]:
        entrees_rangee <span class="op">=</span> rangee.split(<span class="st">&quot;,&quot;</span>)
        regions <span class="op">+=</span> [entrees_rangee[<span class="dv">0</span>]]
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(entrees_rangee)):
            entrees_rangee[i] <span class="op">=</span> <span class="bu">int</span>(entrees_rangee[i])
        liste_homme <span class="op">+=</span> [entrees_rangee[<span class="dv">1</span>:<span class="dv">6</span>]]
        liste_femme <span class="op">+=</span> [entrees_rangee[<span class="dv">6</span>:]]
    
    array_homme <span class="op">=</span> sp.array(liste_homme)
    array_femme <span class="op">=</span> sp.array(liste_femme)
    array_regions <span class="op">=</span> sp.array(regions)

    <span class="cf">return</span> (categories, array_regions, array_homme, array_femme)

<span class="kw">def</span> total_par_region(homme, femme):
    total <span class="op">=</span> homme <span class="op">+</span> femme
    <span class="cf">return</span> total.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)

categories, regions, homme, femme <span class="op">=</span> lecture()
totaux_region <span class="op">=</span> total_par_region(homme, femme)
<span class="co"># Conversion en valeur flottante pour permettre la division (une autre possibilite de d&#39;utiliser float() plutot que int() durant la lecture du fichier)</span>
totaux_region <span class="op">=</span> totaux_region.astype(<span class="bu">float</span>)
pourcentage_femme <span class="op">=</span> femme.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>) <span class="op">/</span> totaux_region
indice_max_femme <span class="op">=</span> (pourcentage_femme <span class="op">==</span> pourcentage_femme.<span class="bu">max</span>())
<span class="bu">print</span> <span class="st">&quot;La region la plus feminine est </span><span class="sc">%s</span><span class="st">&quot;</span> <span class="op">%</span> regions[indice_max_femme][<span class="dv">0</span>]
pourcentage_homme <span class="op">=</span> homme.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>) <span class="op">/</span> totaux_region
indice_max_homme <span class="op">=</span> (pourcentage_homme <span class="op">==</span> pourcentage_homme.<span class="bu">max</span>())
<span class="bu">print</span> <span class="st">&quot;La region la plus masculine est </span><span class="sc">%s</span><span class="st">&quot;</span> <span class="op">%</span> regions[indice_max_homme][<span class="dv">0</span>]

<span class="co"># Nous allons prendre une estimation sur l&#39;age moyen selon les donnes que nous avons.</span>
<span class="co"># Etant donne qu&#39;il y a seulement des categories d&#39;age, nous allons estimer que l&#39;age moyen des gens d&#39;une categorie est l&#39;age moyen de cette categorie.</span>

<span class="co"># Tableau de l&#39;age moyen par categorie</span>
categorie_age <span class="op">=</span> []
<span class="cf">for</span> categorie <span class="op">in</span> categories[:<span class="dv">4</span>]:
    min_cat, max_cat <span class="op">=</span> <span class="bu">int</span>(categorie.split()[<span class="dv">1</span>]), <span class="bu">int</span>(categorie.split()[<span class="dv">3</span>])
    categorie_age <span class="op">+=</span> [<span class="bu">float</span>(max_cat <span class="op">+</span> min_cat) <span class="op">/</span> <span class="dv">2</span>]
<span class="co"># Que veut dire le 75 et +? Estimons avec la valeur 90</span>
categorie_age <span class="op">+=</span> [<span class="fl">90.0</span>]

<span class="co"># Resultat attendu:</span>
<span class="co"># categorie_age = array([9.5, 29.5, 49.5, 67.0, 90.0]) </span>

age_moyen_par_region <span class="op">=</span> sp.dot(homme<span class="op">+</span>femme, categorie_age)
<span class="bu">print</span> <span class="st">&quot;La region la plus peuplee est </span><span class="sc">%s</span><span class="st">&quot;</span> <span class="op">%</span> regions[age_moyen_par_region <span class="op">==</span> age_moyen_par_region.<span class="bu">max</span>()][<span class="dv">0</span>]
<span class="bu">print</span> <span class="st">&quot;La region la moins peuplee est </span><span class="sc">%s</span><span class="st">&quot;</span> <span class="op">%</span> regions[age_moyen_par_region <span class="op">==</span> age_moyen_par_region.<span class="bu">min</span>()][<span class="dv">0</span>]

correlation <span class="op">=</span> sp.corrcoef(homme <span class="op">+</span> femme)
<span class="co"># Soustraire la matrice identite permet de supprimer les correlations a 1 </span>
<span class="co"># d&#39;une ligne a elle meme</span>
correlation <span class="op">=</span> correlation <span class="op">-</span> sp.identity(correlation.shape[<span class="dv">0</span>])

<span class="bu">print</span> <span class="st">&quot;Les regions ou les pyramides des ages sont les plus proches sont &quot;</span><span class="op">\</span>
    <span class="op">+</span> <span class="st">&quot; et &quot;</span>.join(regions[sp.where(correlation <span class="op">==</span> correlation.<span class="bu">max</span>())[<span class="dv">0</span>]])</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li><p>Modifier le script pour ajouter une fonction qui affiche sous forme d'une pyramide des âges, le recensement cumulé d'une liste de noms de régions. (La fonction devrait prendre en entrée cette liste de nom de régions.)</p>
<p>Exemple de sortie (la vôtre peut être très différente):</p>
<div class="figure">
<img src="pyramide.png" alt="image" />
<p class="caption">image</p>
</div></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pylab <span class="im">as</span> pl
<span class="co"># Supposons que le premier fichier est appelle &#39;population.py&#39;</span>
<span class="im">import</span> population

categories, regions, homme, femme <span class="op">=</span> population.lecture()
<span class="co"># Obtenir les categories d&#39;age sans sexe</span>
ages <span class="op">=</span> []
<span class="cf">for</span> categorie <span class="op">in</span> categories[:<span class="dv">5</span>]:
    ages <span class="op">+=</span> [categorie.split(<span class="st">&quot;Homme &quot;</span>)[<span class="dv">1</span>]]

<span class="kw">def</span> dessiner_pyramide(regions_demandes):
    indices_demandes <span class="op">=</span> []
    <span class="cf">for</span> nom <span class="op">in</span> regions_demandes:
        <span class="co">#Pas tres joli parce qu&#39;on sort un element d&#39;un array avec [0][0] et on le remet dans une liste.</span>
        indices_demandes <span class="op">+=</span> [pl.where(regions <span class="op">==</span> nom)[<span class="dv">0</span>][<span class="dv">0</span>]]

    pl.title(<span class="st">&quot;Pyramide des ages&quot;</span>)
    total_homme <span class="op">=</span> homme[indices_demandes].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)
    total_femme <span class="op">=</span> femme[indices_demandes].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>)
    graphe_homme <span class="op">=</span> pl.barh(pl.arange(<span class="bu">len</span>(ages))<span class="op">+</span><span class="fl">0.1</span>, total_homme, height<span class="op">=</span><span class="fl">0.4</span>, label<span class="op">=</span><span class="st">&quot;Hommes&quot;</span>, color<span class="op">=</span><span class="st">&#39;b&#39;</span>)
    graphe_femme <span class="op">=</span> pl.barh(pl.arange(<span class="bu">len</span>(ages))<span class="op">+</span><span class="fl">0.5</span>, total_femme, height<span class="op">=</span><span class="fl">0.4</span>, label<span class="op">=</span><span class="st">&quot;Femmes&quot;</span>, color<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    pl.ylabel(<span class="st">&quot;Ages&quot;</span>)
    pl.yticks(pl.arange(<span class="bu">len</span>(ages)) <span class="op">+</span> <span class="fl">0.5</span>, ages)
    pl.xlabel(<span class="st">&quot;Habitants&quot;</span>)
    pl.legend((graphe_homme[<span class="dv">0</span>], graphe_femme[<span class="dv">0</span>]), (<span class="st">&#39;Hommes&#39;</span>,<span class="st">&#39;Femmes&#39;</span>))
    pl.show()

regions_demandes <span class="op">=</span> <span class="bu">raw_input</span>(<span class="st">&quot;Entrez une liste de regions separe de virgules : &quot;</span>)
dessiner_pyramide(regions_demandes.split(<span class="st">&quot;,&quot;</span>))</code></pre></div>
<h2 id="exercice-2---ensemble-de-mandelbrot">Exercice 2 - Ensemble de Mandelbrot</h2>
<p><em>D'après Wikipédia</em></p>
<p>L'<em>ensemble de Mandelbrot</em> est une fractale qui est définie comme l'ensemble des points <strong>c</strong> du plan complexe pour lesquels la suite récurrente définie par : <strong>z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c</strong> et la condition <strong>z<sub>0</sub> = 0</strong> ne tend pas vers l'infini (en module). Si nous reformulons cela sans utiliser les nombres complexes, en remplaçant <strong>z<sub>n</sub></strong> par le couple <strong>(x<sub>n</sub>, y<sub>n</sub>)</strong> et <strong>c</strong> par le couple <strong>(a, b)</strong> alors nous obtenons: <strong>x<sub>n+1</sub> = x<sub>n</sub><sup>2</sup> - y<sub>n</sub><sup>2</sup> + a</strong> et <strong>y<sub>n+1</sub> = 2x<sub>n</sub>y<sub>n</sub> + b</strong>.</p>
<p>Il peut être démontré que dès que le module de <strong>z<sub>n</sub></strong> est strictement plus grand que 2 (<strong>z<sub>n</sub></strong> étant sous forme algébrique, quand <strong>x<sub>n</sub><sup>2</sup> + y<sub>n</sub><sup>2</sup> &gt; 2</strong>), la suite diverge vers l'infini, et donc <strong>c</strong> est en dehors de l'ensemble de Mandelbrot. Cela nous permet d'arrêter le calcul pour les points ayant un module strictement supérieur à 2 et qui sont donc en dehors de l'ensemble de Mandelbrot. Pour les points de l'ensemble de Mandelbrot, i.e. les nombres complexes <strong>c</strong> pour lesquels <strong>z<sub>n</sub></strong> ne tend pas vers l'infini, le calcul n'arrivera jamais à terme, donc il doit être arrêté après un certain nombre d'itérations déterminé par le programme.</p>
<p>Écrire un script qui affiche (une approximation de) l'ensemble de Mandelbrot.</p>
<p><br />
<img src="mandelbrot.png" alt="image" /></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pylab <span class="im">as</span> pl
taille_grille <span class="op">=</span> <span class="dv">501</span>
<span class="co"># Points dans l&#39;espace a tester.</span>
a <span class="op">=</span> pl.linspace(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>,taille_grille)
b <span class="op">=</span> pl.linspace(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>,taille_grille)[:, pl.newaxis]
<span class="co"># Matrices ou toutes les rangees sont les memes</span>
Mb <span class="op">=</span> b <span class="op">+</span> pl.zeros(taille_grille)
<span class="co"># Matrices ou toutes les colonnes sont les memes</span>
Ma <span class="op">=</span> a <span class="op">+</span> pl.zeros(taille_grille)[:, pl.newaxis]
<span class="co"># Trouver si chacun des points converge</span>
limite <span class="op">=</span> <span class="dv">20</span>
<span class="co"># z_0 = 0 partout</span>
x <span class="op">=</span> pl.zeros(Ma.shape)
y <span class="op">=</span> pl.zeros(Ma.shape)
<span class="co"># Pas necessaire, mais gardons le nombre d&#39;iteration que chaque point a diverge</span>
temps_de_divergence <span class="op">=</span> pl.zeros(Ma.shape)
<span class="co"># Trouve la suite z_n</span>
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(limite):
    (x, y) <span class="op">=</span> (x<span class="op">*</span>x <span class="op">-</span> y<span class="op">*</span>y <span class="op">+</span> a, <span class="dv">2</span><span class="op">*</span>x<span class="op">*</span>y <span class="op">+</span> b)
    <span class="co"># Tronquer les entrees deja divergente</span>
    x[x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">4</span>] <span class="op">=</span> <span class="dv">4</span>
    y[x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">4</span>] <span class="op">=</span> <span class="dv">4</span>
    temps_de_divergence[x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">4</span>] <span class="op">+=</span> <span class="dv">1</span>

z <span class="op">=</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>
pl.imshow(z)
<span class="co"># C&#39;est aussi possible de regarder les temps de divergence</span>
pl.imshow(temps_de_divergence)</code></pre></div>
                </td>
              </tr>
            </table>
                        <br />
          </td>
        </tr>
      </table>
    </td>
  </tr>

  <tr class="pos1">
    <td height="20" colspan="2" class="bottom" align="right">
    Website design modified from <a
    href="http://www.oswd.org/design/information/id/879">Sliqua</a>
    taken from <a href="http://www.oswd.org">OSWD</a>
    </td>
  </tr>
</table>
</body>
</html>

